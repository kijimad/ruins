# Stackableアイテムのリファクタリング計画

## 概要

現在のStackable実装を改善し、全アイテムが統一的な`Count`フィールドを持つ設計に移行する。Stackableコンポーネントはマーカーとして残し、スタック可能性を明示する。

**作成日**: 2026-01-14
**最終更新**: 2026-01-14
**ステータス**: 計画中
**優先度**: 中（技術的負債の解消）

---

## 現在の設計と問題点

### 現在の実装

```go
// 現在: Stackableは別コンポーネント
type Item struct{}  // 空のマーカー

type Stackable struct {
    Count int  // Stackableアイテムのみ持つ
}

// 使用時に分岐が頻繁に発生
func ConsumeItem(world w.World, item ecs.Entity, owner ecs.Entity) {
    if item.HasComponent(world.Components.Stackable) {
        ChangeStackableCount(world, item, owner, -1)
    } else {
        world.Manager.DeleteEntity(item)
        markInventoryChanged(world, owner)
    }
}

func SpawnItem(world w.World, name string, locationType gc.ItemLocationType, count int) (ecs.Entity, error) {
    // ... エンティティ作成 ...

    // Stackableコンポーネントがある場合はcountを設定
    if item.HasComponent(world.Components.Stackable) {
        stackable := world.Components.Stackable.Get(item).(*gc.Stackable)
        stackable.Count = count
        return item, nil
    }

    // 非Stackableアイテムの場合はcount回繰り返しスポーン
    for i := 1; i < count; i++ {
        // ... 複雑なループ処理 ...
    }
}
```

### 問題点

1. **呼び出し側の分岐が多い**: `HasComponent(Stackable)` チェックが頻繁に必要
2. **重複したロジック**: Stackable/非Stackableで似た処理が分岐
3. **SpawnItemの複雑さ**: 非Stackableを複数生成するループ処理
4. **一貫性のない関数**:
   - `ChangeStackableCount`: Stackable専用
   - `ConsumeItem`: 内部で分岐
   - `GetItemCount`: ヘルパーが必要
5. **重量計算での分岐**:
```go
// weight.go:40-47
if itemEntity.HasComponent(world.Components.Stackable) {
    stackable := world.Components.Stackable.Get(itemEntity).(*gc.Stackable)
    count = stackable.Count
}
totalWeight += weight.Kg * float64(count)
```

---

## CDDAの設計思想

### CDDAの実装

```cpp
// CDDA: 全アイテムが charges を持つ
struct item {
    int charges;  // 全アイテムが持つフィールド

    // アイテムタイプから判定
    bool count_by_charges() const {
        return stackable_ || ammo || (comestible && phase != phase_id::SOLID);
    }

    // 統一的なインターフェース
    int count() const {
        return count_by_charges() ? charges : 1;
    }

    // 重量計算もシンプル
    units::mass weight(bool include_contents = true) const {
        if (count_by_charges()) {
            ret_mul *= charges;
        }
        return ret * ret_mul;
    }
};
```

### CDDAの利点

1. **単一の真実**: `charges` フィールドが唯一の数量情報源
2. **分岐の最小化**: `count()` メソッドで抽象化
3. **型による判定**: アイテムタイプ（Raw data）に `stackable` フラグ
4. **シンプルな操作**: 全アイテムに対して同じ操作

---

## 提案する新設計

### 新しい構造

```go
// 新設計: すべてのアイテムがCountを持つ
type Item struct {
    Count int  // すべてのアイテムが持つ（非スタックは常に1）
}

// Stackableコンポーネントはマーカーとして残す
type Stackable struct {
    // 空でOK（存在自体がスタック可能性を示す）
}

// マージ判定: Stackableコンポーネントの有無で判定（分岐は残る）
func AddItemToBackpack(world w.World, item ecs.Entity, owner ecs.Entity) {
    // Stackableコンポーネントがある場合はマージ判定
    if item.HasComponent(world.Components.Stackable) {
        itemName := world.Components.Name.Get(item).(*gc.Name).Name
        existingEntity, shouldMerge := FindStackableInInventory(world, itemName)

        if shouldMerge {
            // Item.Count に加算
            existingItem := world.Components.Item.Get(existingEntity).(*gc.Item)
            newItem := world.Components.Item.Get(item).(*gc.Item)
            existingItem.Count += newItem.Count

            world.Manager.DeleteEntity(item)
            markInventoryChanged(world, owner)
            return
        }
    }

    // 非スタック or 既存なし → 新規エンティティとして追加
    item.RemoveComponent(world.Components.ItemLocationOnField)
    item.AddComponent(world.Components.ItemLocationInBackpack, gc.LocationInBackpack{})
    markInventoryChanged(world, owner)
}

// 消費・重量計算など: 統一的な関数（分岐なし）
func ChangeItemCount(world w.World, item ecs.Entity, owner ecs.Entity, amount int) {
    itemComp := world.Components.Item.Get(item).(*gc.Item)
    itemComp.Count += amount

    if itemComp.Count <= 0 {
        world.Manager.DeleteEntity(item)
    }

    markInventoryChanged(world, owner)
}

func ConsumeItem(world w.World, item ecs.Entity, owner ecs.Entity) {
    ChangeItemCount(world, item, owner, -1)
}

// 重量計算: 分岐なし
func CalculateCurrentCarryingWeight(world w.World, entity ecs.Entity) float64 {
    var totalWeight float64

    world.Manager.Join(world.Components.Item, world.Components.Weight).Visit(func(itemEntity ecs.Entity) {
        weight := world.Components.Weight.Get(itemEntity).(*gc.Weight)
        item := world.Components.Item.Get(itemEntity).(*gc.Item)

        // 分岐不要
        totalWeight += weight.Kg * float64(item.Count)
    })

    return totalWeight
}
```

---

## 移行計画

### Phase 1: 準備（影響範囲の調査）

**目的**: 変更が必要な箇所をすべて特定する

**タスク**:
- [ ] `Stackable` コンポーネントの使用箇所をリストアップ
- [ ] `HasComponent(world.Components.Stackable)` の出現箇所を特定
- [ ] Rawデータ（TOML）の `stackable` フラグ使用状況を確認
- [ ] テストケースの洗い出し

**対象ファイル**:
- `lib/components/components.go`
- `lib/worldhelper/spawn.go`
- `lib/worldhelper/inventory.go`
- `lib/worldhelper/stackable.go`
- `lib/worldhelper/weight.go`
- `lib/worldhelper/shop.go`
- `lib/worldhelper/craft.go`
- `lib/raw/raw.go`
- `assets/raw/items/*.toml`

### Phase 2: データ構造の変更

**目的**: 新しいコンポーネント構造を導入

**タスク**:
- [ ] `Item` コンポーネントに `Count` フィールドを追加
```go
type Item struct {
    Count int  // デフォルト: 1
}
```
- [ ] `Stackable` コンポーネントを空の構造体に変更（マーカーとして機能）
```go
type Stackable struct {
    // 空でOK（存在自体がスタック可能性を示す）
}
```
- [ ] `NewItemSpec` を修正し、`Item.Count` を設定するように変更
```go
func (m *Master) NewItemSpec(name string) (*gc.EntitySpec, error) {
    // ...
    entitySpec.Item = &gc.Item{Count: 1}  // デフォルト1

    // Stackableフラグがある場合は空のStackableコンポーネントを付ける
    if rawItem.Stackable {
        entitySpec.Stackable = &gc.Stackable{}
    }
}
```

### Phase 3: 関数の統一

**目的**: 分岐を含む関数を統一的な実装に置き換える

**優先順位の高い関数**:

1. **ChangeItemCount（新規作成）**
```go
// 旧: ChangeStackableCount
// 新: ChangeItemCount
func ChangeItemCount(world w.World, item ecs.Entity, owner ecs.Entity, amount int) {
    itemComp := world.Components.Item.Get(item).(*gc.Item)
    itemComp.Count += amount

    if itemComp.Count <= 0 {
        world.Manager.DeleteEntity(item)
    }

    markInventoryChanged(world, owner)
}
```

2. **GetItemCount（統一）**
```go
// 旧: HasComponent + Get による分岐
// 新: 直接 Item.Count を取得
func GetItemCount(world w.World, item ecs.Entity) int {
    itemComp := world.Components.Item.Get(item).(*gc.Item)
    return itemComp.Count
}
```

3. **ConsumeItem（簡略化）**
```go
// 旧: 内部で分岐
// 新: ChangeItemCount(-1) を呼ぶだけ
func ConsumeItem(world w.World, item ecs.Entity, owner ecs.Entity) {
    ChangeItemCount(world, item, owner, -1)
}
```

4. **SpawnItem（大幅簡略化）**
```go
// 非Stackableの複数スポーンループを削除
func SpawnItem(world w.World, name string, locationType gc.ItemLocationType, count int) (ecs.Entity, error) {
    // 1つのエンティティを作成
    item := createEntity(...)

    // Countを設定
    itemComp := world.Components.Item.Get(item).(*gc.Item)
    itemComp.Count = count

    return item, nil
}
```

**タスク**:
- [ ] `ChangeItemCount` を実装
- [ ] `GetItemCount` を修正
- [ ] `ConsumeItem` を簡略化
- [ ] `SpawnItem` を簡略化（ループ削除）
- [ ] `CalculateCurrentCarryingWeight` から分岐を削除
- [ ] `AddStackableCount` を `AddItemCount` にリネーム
- [ ] すべての呼び出し箇所を更新

### Phase 4: テストの更新

**目的**: すべてのテストを新しい実装に対応させる

**タスク**:
- [ ] `spawn_test.go`: Item.Count を使用するテストに更新
- [ ] `inventory_test.go`: Item.Count を使用するテストに更新
- [ ] `weight_test.go`: Item.Count を使用するテストに更新
- [ ] `shop_test.go`: Item.Count を使用するテストに更新
- [ ] `craft_test.go`: Item.Count を使用するテストに更新
- [ ] Stackableコンポーネントはマーカーとして残るため、存在チェックのテストは維持
- [ ] すべてのテストが通ることを確認

### Phase 5: 旧関数の削除とクリーンアップ

**目的**: 使われなくなった旧関数を削除し、コードをクリーンアップ

**タスク**:
- [ ] `ChangeStackableCount` を削除（`ChangeItemCount` に置き換え済み）
- [ ] `AddStackableCount` を削除（`ChangeItemCount` に置き換え済み）
- [ ] `Stackable.Count` フィールド参照箇所がないことを確認
- [ ] 不要になったヘルパー関数を削除
- [ ] コンパイルエラーがないことを確認
- [ ] すべてのテストが通ることを確認

**注意**: `Stackable` コンポーネント自体はマーカーとして残す

### Phase 6: ドキュメント更新

**目的**: 新しい設計を文書化

**タスク**:
- [ ] `docs/design.md` を更新
- [ ] アイテムシステムの設計ドキュメントを更新
- [ ] コード内コメントを更新
- [ ] CHANGELOG.md に破壊的変更を記載

---

## メリット・デメリット

### メリット

1. **コードのシンプル化**
   - 消費・重量計算などで分岐が不要
   - 関数の見通しが良くなる
   - 重複コードの削減

2. **保守性の向上**
   - 1箇所の変更で済む（Item.Count）
   - バグの混入リスク低減
   - 新機能追加が容易

3. **一貫性**
   - すべてのアイテムが同じインターフェース（Item.Count）
   - 統一的な操作が可能

4. **Stackableコンポーネントの利点**
   - マーカーとして明示的（Raw data参照不要）
   - `HasComponent` チェックが高速
   - 既存コードとの互換性が高い

5. **拡張性**
   - スタック上限の実装が容易
   - 部分スタック（一部だけ移動）が簡単

### デメリット

1. **移行コスト**
   - 中規模な変更が必要
   - すべてのテストを修正
   - セーブデータの互換性問題

2. **リスク**
   - バグ混入の可能性
   - 予期しない副作用

3. **マージ判定の分岐**
   - マージ判定時の `HasComponent(Stackable)` 分岐は残る
   - ただし、それ以外の操作（消費、重量など）は統一的

4. **非Stackableアイテムの無駄**
   - Countが常に1のアイテムでもフィールドを持つ
   - メモリ的にはごくわずか（int 1つ）

---

## リスク管理

### リスクと対策

| リスク | 影響度 | 対策 |
|--------|--------|------|
| バグ混入 | 高 | 段階的な移行、各Phase後にテスト実行 |
| セーブデータ破損 | 中 | マイグレーション機能の実装 |
| パフォーマンス低下 | 低 | ベンチマーク測定 |
| 機能の見落とし | 中 | 影響範囲の事前調査（Phase 1） |

### ロールバック計画

- 各Phaseをgitブランチで管理
- 問題が発生した場合は前のPhaseに戻る
- セーブデータは別途バックアップ

---

## 参考資料

### CDDA実装

**ソースコード**:
- `Cataclysm-DDA/src/item.h`: `count_by_charges()`, `count()`
- `Cataclysm-DDA/src/item.cpp`: `weight()` 実装
- `Cataclysm-DDA/src/itype.h`: `stackable_` フラグ

**重要なメソッド**:
```cpp
// item.h
int charges;  // すべてのアイテムが持つ

bool count_by_charges() const {
    return stackable_ || ammo || (comestible && phase != phase_id::SOLID);
}

int count() const {
    return count_by_charges() ? charges : 1;
}

// item.cpp - weight関数
if (count_by_charges()) {
    ret_mul *= charges;
}
```

### CDDAのPR・Issue

- Issue #35953: Multiple stacks of same items
- Issue #60277: Performance with large stackable items
- PR #73492: Weight calculation fixes

### Ruinsの関連ドキュメント

- `docs/design.md`: 現在の設計
- `docs/weight_system_implementation.md`: 重量システム実装
- `cdda/cataclysm-dda-game-design-analysis.md`: CDDA分析

---

## 実装予定時期

**短期（現在）**: Phase 1（影響範囲調査）を実施
**中期（次の大型アップデート）**: Phase 2-3（コア実装）
**長期（安定版リリース前）**: Phase 4-6（完全移行）

---

## 進捗状況

**最終更新**: 2026-01-14

- [x] 問題点の特定
- [x] CDDAの設計調査
- [x] 移行計画の策定（Stackableマーカー方式）
- [ ] Phase 1: 準備
- [ ] Phase 2: データ構造変更
- [ ] Phase 3: 関数統一
- [ ] Phase 4: テスト更新
- [ ] Phase 5: 旧関数の削除
- [ ] Phase 6: ドキュメント更新

---

## 関連する今後の改善

このリファクタリング後に可能になる機能：

1. **スタック上限の実装**
```go
type Item struct {
    Count    int
    MaxStack int  // Raw dataから取得
}
```

2. **部分スタック移動**
```go
func SplitStack(world w.World, item ecs.Entity, amount int) ecs.Entity {
    // 一部だけを新しいエンティティに分離
}
```

3. **スタックマージの自動化**
```go
func TryMergeStacks(world w.World, item1, item2 ecs.Entity) bool {
    // 同じアイテムなら自動でマージ
}
```

4. **インベントリのソート・整理**
   - スタック数でソート
   - 自動的に同じアイテムをマージ

---

## まとめ

このリファクタリングは、以下の方針で実装する：

1. **`Item.Count`**: すべてのアイテムが持つ（非スタックは常に1）
2. **`Stackable` コンポーネント**: マーカーとして残す（空の構造体）
3. **スタック判定**: `HasComponent(Stackable)` で高速判定
4. **統一的な操作**: 消費・重量計算などで分岐不要

この設計は、CDDAの思想（全アイテムが `charges` を持つ）を取り入れつつ、既存の `Stackable` コンポーネントを活かすことで、移行コストを抑えた現実的なアプローチとなっている。

マージ判定の分岐は残るが、それ以外の多くの箇所で統一的なコードになり、保守性とシンプルさが向上する。段階的な移行により、リスクを最小限に抑えながら、着実に改善を進めることができる。
