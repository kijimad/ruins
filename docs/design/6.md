# 橋遷移システム設計

## 概要

階層間の移動を「橋を渡る」という形で実装する。各階層には複数の橋があり、プレイヤーはどの橋を渡るかを選択できる。橋ごとに異なる次階層が生成される。

**設計方針**: 既存のゲームシステム（Interaction、Tile、Entity）を最大限活用し、最小限の変更で実現する。

## 要件

1. 各階層の上部に3つ（休憩階層では4つ）の橋がある
2. 橋を渡ると次の階層へ移動（一方通行）
3. 橋ごとに異なる次階層が生成される（シード値が異なる）
4. 各階層の下部には1つの橋（到着地点）がある
5. 橋は複数のタイルで構成される

## 既存システムとの統合

### 活用する既存機能

- **Interactionシステム**: `WarpNextInteraction` を拡張して `BridgeInteraction` を作成
- **Tileシステム**: 橋タイルを新規追加（通行可能な床タイルの一種）
- **Entityシステム**: 橋エンティティを配置
- **StateEventシステム**: `WarpNextEvent` で階層遷移
- **maptemplateシステム**: テンプレートで橋を配置

## 橋の構成（橋タイル + 橋エンティティ）

橋は以下の2つの要素で構成される：

### 1. 橋タイル（Tile）

- **役割**: 橋の見た目と通行可能性
- **特性**:
  - `blocks_movement = false` （通行可能）
  - `blocks_sight = false` （視界を遮らない）
- **種類**: bridge_a, bridge_b, bridge_c, bridge_d
- **配置**: 橋の全体（複数タイル）

### 2. 橋エンティティ（Entity）

- **役割**: 階層遷移の機能
- **配置**: 橋の端（遷移ポイント）に1つだけ
- **コンポーネント**:
  - `Interactable`: `BridgeInteraction` を持つ
  - `Name`: 橋の名前（「橋A」など）
  - `GridElement`: 位置情報

### 構成イメージ

```
階層上部（出口）:
┌──────────────────────────────────┐
│ [橋A][橋A][橋A][エンティティA]   │ ← 橋A（左）
│ [橋B][橋B][橋B][エンティティB]   │ ← 橋B（中央）
│ [橋C][橋C][橋C][エンティティC]   │ ← 橋C（右）
│                                    │
│         探索エリア                 │
│                                    │
│ [エンティティ入口][橋][橋][橋]   │ ← 下部の橋（入口）
└──────────────────────────────────┘

[橋タイル]: 通行可能な床タイル（橋の見た目）
[エンティティ]: BridgeInteraction を持つエンティティ（遷移機能）
```

## データ構造

### BridgeInteraction（新規追加）

```go
// BridgeInteraction は橋を渡る相互作用
type BridgeInteraction struct {
    BridgeID      string // 橋の識別子（"A", "B", "C", "D"）
    NextFloorSeed uint64 // 次階層生成用のシード値
}

// Config は相互作用設定を返す
func (b BridgeInteraction) Config() InteractionConfig {
    return InteractionConfig {
        ActivationRange: ActivationRangeSameTile,
        ActivationWay:   ActivationWayAuto, // 橋の端に到達したら自動遷移
    }
}
```

### 橋タイル定義（raw.toml に追加）

```toml
# 橋タイル
[tile.bridge_a]
name = "橋A"
blocks_movement = false
blocks_sight = false
sprite_index = [X, Y]  # スプライトシート上の座標

[tile.bridge_b]
name = "橋B"
blocks_movement = false
blocks_sight = false
sprite_index = [X, Y]

[tile.bridge_c]
name = "橋C"
blocks_movement = false
blocks_sight = false
sprite_index = [X, Y]

[tile.bridge_d]
name = "橋D（帰還）"
blocks_movement = false
blocks_sight = false
sprite_index = [X, Y]
```

## 階層構成

### 通常階層（1-4, 6-9階等）

**上部（出口）**: 3つの橋
- 橋A: X=10, Y=1（左）
- 橋B: X=25, Y=1（中央）
- 橋C: X=40, Y=1（右）
- 各橋の長さ: 4タイル

**下部（入口）**: 1つの橋
- X=25, Y=45（中央）

### 休憩階層（5, 10, 15階等）

**上部（出口）**: 4つの橋
- 橋A: X=8, Y=1
- 橋B: X=18, Y=1
- 橋C: X=28, Y=1
- 橋D: X=38, Y=1（街への帰還用）

**下部（入口）**: 1つの橋
- X=25, Y=45（中央）

## マップ生成

### テンプレート定義例

```toml
# templates/50x50_normal_with_bridges.toml
name = "50x50_normal_bridges"
weight = 100
size = {w = 50, h = 50}

map = """
..................................................
..AAAA........BBBB..........CCCC..............
..................................................
# ... 探索エリア ...
..................................................
..................####........................
..................................................
"""

[palette]
terrain."." = "floor"
terrain."#" = "wall"
terrain."A" = "bridge_a"
terrain."B" = "bridge_b"
terrain."C" = "bridge_c"

# 橋エンティティの配置（橋の端に配置）
[[placements]]
chunks = ["bridge_entity_a"]
x = 13
y = 1

[[placements]]
chunks = ["bridge_entity_b"]
x = 29
y = 1

[[placements]]
chunks = ["bridge_entity_c"]
x = 43
y = 1
```

### 橋エンティティのテンプレート

```toml
# templates/entities/bridge_entity_a.toml
name = "bridge_entity_a"
weight = 100
size = {w = 1, h = 1}

map = "B"

[palette]
terrain."B" = "floor"  # 橋タイルの上に配置されるので床でOK

# エンティティとして橋Aをスポーン
npc."B" = "bridge_a"
```

```toml
# raw/raw.toml に追加
[entity.bridge_a]
name = "橋A"
components = ["interactable"]
interactable_type = "bridge"
bridge_id = "A"
# NextFloorSeedはスポーン時に動的に計算
```

## 処理フロー

### 1. マップ生成時

```
DungeonState.OnStart()
  ↓
mapplanner.Plan(seed, builderType)
  ↓
テンプレート選択
  - 階層レベルに応じて橋レイアウトを選択
  - 通常階層: 3つの橋
  - 休憩階層: 4つの橋
  ↓
橋タイルを配置
  ↓
mapspawner.Spawn()
  ↓
橋エンティティをスポーン
  - BridgeInteraction を設定
  - BridgeID を設定（"A", "B", "C", "D"）
  - NextFloorSeed を計算
    baseSeed = 現在のDepth + GameSeed
    bridgeOffset = {"A": 1000, "B": 2000, "C": 3000, "D": 4000}
    NextFloorSeed = baseSeed + bridgeOffset[BridgeID]
  ↓
プレイヤーを下部の橋（入口）に配置
```

### 2. プレイヤーが橋を渡る

```
プレイヤー移動
  ↓
橋エンティティのタイルに到達
  ↓
AutoInteractionSystem が発動
  ↓
InteractionActivateActivity 作成
  ↓
DoTurn() で executeBridge() 呼び出し
  ↓
WarpNextEvent を発行
  - Dungeon.NextFloorSeed = bridge.NextFloorSeed
  - Dungeon.SelectedBridgeID = bridge.BridgeID (ログ用)
  ↓
gamelog に「橋Xを渡った」メッセージ
```

### 3. 階層遷移

```
DungeonState.HandleAction()
  ↓
WarpNextEvent を検出
  ↓
新しい DungeonState を Push
  - Depth = 現在 + 1
  - Seed = Dungeon.NextFloorSeed
  - BuilderType = 適切なタイプ
  ↓
新しい DungeonState.OnStart()
  ↓
次階層を生成（上記の「1. マップ生成時」フロー）
```

## シード値の計算ロジック

```go
// worldhelper/spawn_bridge.go

func CalculateBridgeSeed(baseDepth int, gameSeed uint64, bridgeID string) uint64 {
    // 橋ごとのオフセット
    offsets := map[string]uint64{
        "A": 1000,
        "B": 2000,
        "C": 3000,
        "D": 4000,
    }

    baseSeed := uint64(baseDepth) + gameSeed
    offset := offsets[bridgeID]

    return baseSeed + offset
}
```

## 実装の変更点まとめ

### 新規追加ファイル

1. **templates/50x50_normal_with_bridges.toml** - 通常階層の橋レイアウト
2. **templates/50x50_rest_with_bridges.toml** - 休憩階層の橋レイアウト
3. **templates/entities/bridge_entity_*.toml** - 橋エンティティ定義

### 変更ファイル

#### 1. `internal/components/interactable.go`

```go
// 追加
type BridgeInteraction struct {
    BridgeID      string
    NextFloorSeed uint64
}

func (b BridgeInteraction) Config() InteractionConfig {
    return InteractionConfig{
        ActivationRange: ActivationRangeSameTile,
        ActivationWay:   ActivationWayAuto,
    }
}
```

#### 2. `internal/raw/raw.toml`

```toml
# 橋タイル定義を追加
[tile.bridge_a]
# ...

[tile.bridge_b]
# ...

[tile.bridge_c]
# ...

[tile.bridge_d]
# ...

# 橋エンティティ定義を追加
[entity.bridge_a]
name = "橋A"
# ...
```

#### 3. `internal/actions/interaction_activate.go`

```go
// DoTurn() に追加
case gc.BridgeInteraction:
    ia.executeBridge(act, world, content)

// 新規メソッド
func (ia *InteractionActivateActivity) executeBridge(
    act *Activity,
    world w.World,
    bridge gc.BridgeInteraction,
) {
    // NextFloorSeed を Dungeon リソースに保存
    world.Resources.Dungeon.NextFloorSeed = bridge.NextFloorSeed
    world.Resources.Dungeon.SelectedBridgeID = bridge.BridgeID

    // WarpNextEvent を発行
    world.Resources.Dungeon.SetStateEvent(resources.WarpNextEvent{})

    // ログ出力
    if isPlayerActivity(act, world) {
        gamelog.New(gamelog.FieldLog).
            Magic(fmt.Sprintf("橋%sを渡った。", bridge.BridgeID)).
            Log()
    }
}
```

#### 4. `internal/resources/level.go`

```go
type Dungeon struct {
    // 既存フィールド...

    // 追加
    NextFloorSeed    uint64 // 次階層のシード値（橋選択で決定）
    SelectedBridgeID string // 選択された橋のID（ログ用）
}
```

#### 5. `internal/worldhelper/spawn.go`

```go
// 新規関数
func SpawnBridge(
    world w.World,
    bridgeID string,
    x, y int,
    currentDepth int,
    gameSeed uint64,
) ecs.Entity {
    // 橋エンティティを生成
    // BridgeInteraction を設定
    // NextFloorSeed を計算して設定
}
```

## メリット

1. **既存システムとの整合性**: Interaction システムをそのまま活用
2. **シンプル**: 橋は既存のタイル + エンティティの組み合わせ
3. **最小限の変更**: 既存コードへの影響を抑える
4. **拡張性**: 新しい橋タイプを簡単に追加可能
5. **パフォーマンス**: エンティティ数を最小限に抑える
6. **テスト容易性**: 既存のテストフレームワークを利用可能

## 将来の拡張案

1. **橋の状態**: 壊れた橋、有料の橋など
2. **橋のヒント**: 各橋の先に何があるかのヒント表示
3. **橋の外観バリエーション**: 木の橋、石の橋など
4. **動的な橋数**: 階層によって橋の数を動的に変更
5. **橋の難易度表示**: 次階層の難易度を色で表現
